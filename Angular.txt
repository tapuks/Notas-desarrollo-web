<<<<<<< HEAD
----INTALAR ANGULAR 
	npm install -g @angular/cli
NUEVO PROYECTO
	ng new NombreDelProyecto
LEVANTAR SERVIDOR
	ng serve / npm run start
LOCAL HOST
	http://localhost:4200
NUEVO COMPONENTE
	ng generate c components/nuevoComponente
	ng generate c nuevoComponente --skipTests   ->Elimina los documentos de test
CREAR SERVICE
	ng g service shared/data
	ng generate service services/Personas --skipTests
INSTALAR TYPESCRIPT
	npm install -g typescript

-----------------------------------

INTERFAZ es una serie de normas, metodos que he definido en la interfaz y que tiene cumplir quien implemente esa interfaz
MVC - VISTA (HTML, CSS), CONTROLADOR (CLASE)

SERVICIO es una clase que se encarga de realizar unas acciones concretas sobre los diferentes datos de la aplicacion. Asi no tienes los datos en cada componente

  constructor() {
    console.log('Lo uso para inicilizar propiedades');
    }
  ngOnInit(): void {
    console.log('Lo uso para lanzar acciones al arrancar el componente');
  }
  ngAfterViewInit(){
    console.log('Lo uso para lanzar acciones iniciales dentro de la plantilla');
  }

__________________________________________________________

FUNCION
function sumar(a,b){
	return a+b
}
const sumar = function(a:number, b:number):number {
	return a+b
}
//con ?puedes pasar el parametro o no
function nombre(nombre: string, apellido?: string):string {
	if(apellido) return nombre + apellido
	else return nombre
}
//con ... puedes pasar todos los parametro que quieras
function nombres(nombre: string, ...restoNombres: string[]):string {
	return nombre + " " + retoNombres.join(' ')
}
________________________________________________________________

//ngFor
<ul>
    <li *ngFor="let user of users; let indice= index">
        {{user.name}}
    </li>
</ul>
__________________________________________________________
export class NuevoComponenteComponent implements OnInit {
//DECLARACION DE VARIABLES
	mensaje: string;
	personas: any[];
  
//INICIACION DE VARIABLES		
  constructor() {
	this.mensaje= 'Hola que tal'
	this.personas= ['david', 'jazmin']
 }

  ngOnInit(): void {
  }
  mensaje(){
    alert(this.mensaje)
  }

}
________________________________________________________
PODEMOS PONER EL JAVASCRIPT EN EL HTML DE ESTAS DOS MANERAS (ID)
<p id={{idParrafo}}> lorem impo</p>
<p [id]="idParrafo"> lorem impo</p>  -> es lo mismo
<div style="margin-top: 100px;"><div style="margin-top: 100px;">
_______________________________________________________
EVENTOS
<button (click)="pulsa()">Pulsaa</button>

 <select (change)="onChange($event)">
    <option value="uno">Uno</option>
    <option value="dos">Dos</option>
    <option value="tres">Tres</option>
  </select>

<input type="text" (input)="onInput($event)">  //PARA LOS INPUT TIPO TEXT




_____________________________________________________________
APUNTES:
_____________________________________________________________
PARA RECORRER UNA LISTA MOSTRANDO SOLO LOS QUE QUERAMOS (DE ESTA MANERA SI SEXO ES IGUAL A TODOS SE VERAN TODOS, SI ES MASCULINO SE MOSTRARAN SOLO LOS MASCULINOS Y SI ES FEMENINO PUES LOS FEMENINOS).
<tr *ngFor="let item of empleados">
                <ng-container *ngIf="sexo=='Todos' || sexo== item.sexo">
                    <th scope="row">{{item.id}}</th>
                    <td>{{item.name}}</td>
                    <td>{{item.apellido}}</td>
                    <td>{{item.sexo}}</td>
                    <td>{{item.salario}}</td>
                </ng-container>
            </tr>

-------<ng-container></<ng-container> ES UNA ETIQUETA QUE SE CREA COMO SI FUERA UN DIV, EN EL EJEMPLO DE ARRIBA ESTA PARA PONER UN IF.

-------PARA FILTRAR UN ARRAY PODEMOS USAR FILTER (ESTO RETORNA UN ARRAY Y AL PONERLE EL .LENGTH SABEMOS CUANTOS HAY)
  countFemenino() {
    return this.empleados.filter(empleado => empleado.sexo === 'Femenino').length
  }

PARA PASAR UN VALOR JAVASCRIPT SE LE PONE CORCHETE 
	<app-suma [num1]="25" [num2]="24" ></app-suma>

-------PARA RESTAR FECHAS
let today: any = new Date();
    let date: any = new Date(2022,12,28);
    // if (today > date)
    var diferencia = date - today
    let days = diferencia / (1000 * 3600 * 24)

------PARA BORRAR SIN PASAR EL INDEX, PASANDO EL OBJETO ENTERO
delete(producto: Producto) {
    let position = this.productos.indexOf(producto)
    this.productos.splice(position, 1)
  }

------PARA PONER IMAGEN:
<img [src]="producto.imgUrl">
------PUEDES INSTANCIAR LOS OBJETOS ASI:
constructor(
	this.arrayObjetos=[new Obj1('David', 'Berdiell'), new Obj2('Jazmin', 'Correa')]
)
--------
HAY A VECES QUE EL HTML NO DEJA PONER LAS PROPIEDADES DE UN OBJETO, ESO ES PORQUE TODAVIA NO LAS TIENE HASTA QUE LAS RECIBE, SE SOLUCIONA PONIENDO ? POR EJEMPLO <p>casa?.numero</p>


HAY A VECES QUE TIENES DE DECLARAR EL TIPO DE CADA COSA PORQUE SI NO DA ERRROR, ESO ES PORQUE ESTA PUESTO EL MODO ESTRICTO, PARA QUITARLO VAMOS EL DOCUMENTO 
tsconfig.json y ponemos a false la pripiedad strict



____________________________________________________________

_______________________PROPS @INPUT (para passar cosas entre el componente padreal hijo)_____________________________

es como pasar algo por props, necesitamos un @input() en el componente hijo con una variable, esa variable cogera el valor que le pasemos desde el componente padre.
importar Input de @angular/core

export class CalculadoraComponent implements OnInit {
    @Input() mensaje: string
  constructor() {
    this.mensaje='Mensaje de alerta por defecto'
  }
llamamosn al componente <app-calculadora mensaje="Mensaje pasado por @input"></app-calculadora>

PODEMOS CAMBIAR EL NOMBRE DEL PARAMETRO
  @Input('sms') mensaje: string
<app-calculadora sms="Mensaje pasado por @input"></app-calculadora>



_______________________PROPS @OUTPUT (para pasar cosas entre componentes de hijo a padre)_______________________________
importar Output, EventEmitter de @angular/core EN EL HIJO
export class CalculadoraComponent implements OnInit {

    @Output() alertaPulsada: EventEmitter<string>
constructor() {
    this.alertaPulsada= new EventEmitter()
  }
onClick2() {
    this.alertaPulsada.emit('mensaje emitido')
  }

//en el html   <div(click)="onClick2()"> <h1>titulodsds</h1> </div>
//en el html padre  <app-calculadora (alertaPulsada)="onAlertaPulsada($event)"></app-calculadora>
//en el ts del padre   export class AppComponent {
  	title = 'NUEVO';
    	onAlertaPulsada($event:string) {
      console.log($event);
   }
}
____________________PARA PODER MODIFICAR UNA VARIABLE RENDERIZADA DESDE UN INPUT, NO @INPUT _______________________
importamos FormsModule
//en app.module.ts    import { FormsModule } from '@angular/forms';  y en el array de imports ponerlo  imports: [BrowserModule,FormsModule],
// en el html <input type="text" [(ngModel)]="campoTexto">
		<p>{{campoTexto}}</p>
//en el ts    campoTexto :string
  	    constructor() {
   		 this.campoTexto="Valor inicial"
  	    }
__________________________________DIRECTIVAS__________________________________________
<p [ngStyle]="{color:'red', fontSize:'24px'}"> Ponemos estilos.</p>
<p [ngClass]="{semaforo: true, redondo: false}">Mostramos las clases que queramos.</p>
<div class="personaje" [ngClass]="{vivo: item.status == 'Alive', muerto: item.status =='Dead'}">
<p *ngIf="true">Si es true se muestra, si es false no.</p>

<p *ngIf="false; else elseBlock">Si es true se muestra, si es false se muestra el del else</p>
<ng-template #elseBlock>
  <p>Elseee</p>
</ng-template>

<ol>
  <li *ngFor="let persona of personas">
      {{persona.nombre}} {{persona.apellido}}
  </li>
</ol>

<div [ngSwitch]="opcionString">
  <p *ngSwitchCase="'uno'">Opcion 1</p>
  <p *ngSwitchCase="'dos'">Opcion 2</p>
  <p *ngSwitchDefault>Ninguna de las anteriores</p>
</div>

//Para crear una propia directiva->
ng generate directive directivas/Subrayado --skipTests
	import { Directive, ElementRef, Renderer2 } from '@angular/core';
	@Directive({
  		selector: '[appSubrayado]'
	})
		export class SubrayadoDirective {
  			constructor(elem: ElementRef, renderer: Renderer2) {    				
    				renderer.setStyle(elem.nativeElement, 'text-decoration', 'underline')
   		}
	}
Luego lo usas de esta manera: <h1 appSubrayado>Caja Registradora</h1>

//Para crear una directiva que escucha los eventos, como mouseover, mouseout...
import { Directive, ElementRef, Renderer2, HostListener } from '@angular/core';
@Directive({
  selector: '[appColor]'
})
export class ColorDirective {

  constructor(private elem: ElementRef, private render: Renderer2) { }

  @HostListener('mouseover') onHover() {
    this.render.setStyle(this.elem.nativeElement, 'color', 'blue')
  }

}

Tambien puedes hacer que se active una clase con la directiva, usando HostBinding, lo importas.
 @HostBinding('class') isHover:string=''

  constructor(private elem: ElementRef, private render: Renderer2) { }

  @HostListener('mouseover') onHover() {
    this.render.setStyle(this.elem.nativeElement, 'color', 'blue');
    this.isHover = 'hover'  // De esta manera creas en el css una clase .hover y le pones un background o lo que quieras
  }
__________________________________________
//ternario  
    <button (click)="onClick(tarea)">{{tarea.completa? 'INCOMPLETA' : 'COMPLETA'}}</button>
//indice en un for 
	<div class="tarea" *ngFor="let tarea of tareas; let indice= index" [ngClass]="{completa:tarea.completa, incompleta:!tarea.completa}>

____________________NUEVO MODELO______________________________________
export class Producto {
  nombre: string;
  imagen: string;
  precio: number;
  like: boolean;

  constructor(pNombre: string, Pimagen: string, pPrecio: number) {
    this.nombre=pNombre
    this.imagen=Pimagen;
    this.precio=pPrecio;
    this.like = false;
  }
}

_____________________RUTAS_________________________
//en app-routing.module.ts dentro de la const routes que aparece arriba.
const routes: Routes = [
  {path: '', pathMatch:'full', component: Home},
  {path: 'informacion', component: InfoComponent},
  {path: 'about', component: AboutComponent},
  {path: '**', redirectTo: 'about'}
];
//En app.component.html poner    <router-outlet></router-outlet>

PARA IR A UNA RUTA DESDE UN ENLACE, NO PUEDES HACER CON <A HREF=... PORQUE TE RECARGA LA PAGINA.
SE HACE DE ESTA MANERA.
  <a [routerLink]="['/informacion']">Informacion</a>

CON ROUTERLINACTIVE LE PONEMOS UNA CLASE CSS A ESE LINK. SI TENEMOS UN MENU CON VARIOS ENLACES Y AL QUE ESTE ACTIVA LE PONEMOS UNA CLASE CON UN BACKGROUN RED POR EJEMPLO
EL ENLACE QUE HAIGAMOS APRETADO ESTARA EN ROJO.
  <a [routerLink]="['/informacion']" routerLinkActive="activa">Informacion</a>  //Con routerLinkActive le pones una clase al enlace cuando esta en esa ruta

//DESDE UN BOTON.
en el html  <button (click)="onClick()">Ir a about</button>
en el ts 
	export class AppComponent {
  		title = 'Rutas-Angular';
  		constructor(private router: Router) {}
  		onClick() {
    		this.router.navigate(['/about'])
  		}

PARA RECOGER EN NUMERO DE UN ID PASADO POR LA RUTA (IGUAL QUE USE PARAMS):

declaramos la ruta  {path: 'empleado/:id', component: DetalleEmpleadoComponent},
//en el .ts del componente empleado 
	constructor(private activatedRoute: ActivatedRoute) {}
  ngOnInit(): void {
    this.activatedRoute.params.subscribe(params => {
      this.empleadoId = params["id"]
    })
  }

PARA PONER UNA RUTA DENTRO DE OTRA YA. (CHILDREN) POR EJEMPLO SERIA localhost:2400/empleado/5/info
//En las rutas {path: 'empleado/:id', component: DetalleEmpleadoComponent, children: [
    {path: 'modificar', component: ModificarComponent},
    {path: 'info', component: InfoComponent}
  ]}
//IMPORTANTE En el html de ese componente (empleado) hay que poner:   <router-outlet></router-outlet>

Para recoger el id pasado por la ruta desde el padre seria 
constructor(private activatedRoute: ActivatedRoute) {}
  ngOnInit(): void {
    this.activatedRoute.PARENT.params.subscribe(params => {    //.parent porque tien que pasar por el padre
      this.empleadoId = params["id"]
    })
  }

CON ROUTER GUARDS BLOQUEAMOS EL PODER IR A UNA RUTA. VIDEO 78 DE LA BIBLIA DE ANGULAR

_______________________SERVICES__________________________
1- ng generate service services/Personas --skipTests
2- En personas.services.ts declaras una variable y los metodos...
export class PersonasService {
  personas: Persona[]
  constructor() {
    this.personas = [new Persona('David', 'Berdiell', 31, true)]
   }
   getAll(){
     return this.personas
   }
}
3- En el ts del compoenente que quieras usarlo importas la clase PersonaService y:
export class AppComponent {
  title = 'Rutas-Angular';
  constructor(private personaService: PersonasService) {}  //pones la clase en el constructor y ya puedes usar sus metodos
  onClick() {
    let personas = this.personaService.getAll()
  }

_________________________________
DECLARACION DE VARIABLES

ARRAY
let numeros: number[]= [12, 24, 3, 6];
let numeros2: Array<number> = [23, 45, 7]

TUPLA (es un array de posiciones fijas y le podemos definir de que tipo seran)
let sitio: [string, number] = ['Casa', 2022]

ENUM (le asignamos al primer valor el numero 0, al segundo el uno...)
enum Estado {
	offline,
	indefinido,
	online
}

let status: Estado = Estado.online
console.log(status)   -> devuelve el numero que es online (2)

UNKNOWN (NO SABEMOS DE QIE TIPO SERA EL VALOR, PODREMOS MODIFICAR SU VALOR, PERO TIENE ALGUNA RESTRICCION)
let sinTipo: unknown = 'Hola';
sinTipo= 32;

ANY( IGUAL QUE EL UNKNOWN, PERO SIN RESTRICCIONES)

VOID(NO DEVUELVE NADA)
function prueba(): void {
	console.log('probandoo');
}

________________________________________________________

export class AppComponent { @ViewChild("dado1",null) dado1: DadoComponent | undefined; title = 'dados'; number1=0 number2=0 number3=0 // @Output() envioNumeros:EventEmitter<number[]>;

constructor(){ // this.envioNumeros= new EventEmitter() }

generateNumbers(){ // this.number1 = Math.floor(Math.random() * (6 - 1 + 1) + 1); this.number2 = Math.floor(Math.random() * (6 - 1 + 1) + 1); this.number3 = Math.floor(Math.random() * (6 - 1 + 1) + 1); this.dado1.tirar()

}

//DADO COMPONENT tirar(){ this.numero = Math.floor(Math.random() * (6 - 1 + 1) + 1); }

// HTML DEL APP <app-dado #dado1> <app-dado [numero]="number2">

VIEWCHILD (CON ESTO ACCEDEMOS A LOS METODOS DE OTRO COMPONENTE) 
1-EN EL APP.HTML <app-caja #caja> 
2-CAJA.TS hola(){ console.log('holaa'); } 
3-APP.TS @ViewChild("caja",null) caja: CajaComponent | undefined; saludo(){ this.caja.hola() }

__________________________________________________________
PROMESAS

CREAMOS UNA PROMESA EN EL SERVICE

addConor(): Promise<string[]>{
    const prom = new Promise<string[]>((resolve, reject) => {
      const arrTemp = this.perros;
      arrTemp.push('conor')
      resolve(arrTemp)
    })
    return prom;
  }

----y en el ts la llamamos pulsando un boton, como nos llega una promesa tenemos de  poner then y catch

onClickConor() {
    this.service.addConor()
      .then(arrTemp=> console.log(arrTemp))
      .catch(error => console.log(error))
  }

---La forma moderna de resolver la promesa es con async await

 async onClickConor() {
    try {
      const response = await this.ser.addConor()
      console.log(response)	
    }
    catch(error) {
      console.log(error)
    }

OTRO EJEMPLO EN EL SERVICE 
  getAllPromise(): Promise<Escritor[]>{
    return new Promise<Escritor[]>((resolve, reject) => {
      resolve(ESCRITORES)
    })
  }

EN EL TS quitar el void de ngOninit y poner async

async ngOnInit(){
	try{
     this.listaEscritores= await this.promesas.getAllPromise()
	}
catch(error){
	console.log(error)
  	}
}

EN EL SERVICE
getPais(pais:string): Promise<Escritor[]>{
    return new Promise<Escritor[]>((resolve, reject) => {
      resolve(ESCRITORES.filter(escritor=> escritor.pais == pais))
    })
  }
EN EL TS
async changePais($event: any) {
    if ($event.target.value == 'todos') {
      this.listaEscritores = await this.promesas.getAllPromise()
    } else {
    this.listaEscritores = await this.promesas.getPais($event.target.value)
      
    }
  }
EN EL TS USANDO EL ID COGIDO DE LA URL CON PARAMS
   ngOnInit() {
    this.activatedRoute.params.subscribe(async params => {
      console.log(params['id'])
      this.escritor = await this.promesaService.getById(parseInt(params['id']))
    })
  }

__________________________________________________________
HACER PETICIONES importamos en el app.module.ts import { HttpClientModule } from '@angular/common/http';

y en el ts donde lo vayamosa utilizar importamos: 
import {HttpClient} from '@angular/common/http' 
constructor(public http: HttpClient){}

PODEMOS HACERLO CON PROMESA:
GET
getAll(): Promise<any>{
  return this.HttpClient.get<any>(this.url).toPromise()
}
EN EL TS DEL COMPONENTE IMPORTAMOS EN EL CONSTRUCTOR EL SERVICE CON PRIVATE WEBSERVICE:WEBSERVICE
Y LLAMAMOS A FUNCION DEL GET PARA TRAER LA PROMESA:
constructor(private web: WebservicesService) { }
  ngOnInit(){
    this.web.getAll()
      .then(response => {
      console.log(response)
    }).catch(error => console.log(error))
  }


EJEMPLO GET BYID
EN EL SERVICES 
getById(id:number): Promise<any>{
  return this.HttpClient.get<any>(`${this.url}/${id}`).toPromise()
}
EN EL TS DEL COMPONENTE 
// CON PROMESA
 ngOnInit(){
    this.web.getById(3)
      .then(data => console.log('data', data))
      .catch(error=> console.log(error))
  }
// CON ASYNC AWAIT 
async onClick(id: number) {
    try{
	const response=await this.web.getById(id)
	console.log(response)
    }
    catch (error) {
      console.log(error)
    }
  }

TABIEN PODEMOS HACERLO CON UN OBSERVABLE ENVEZDE UNA PROMESA
getDatos(){ this.HttpClient.get("https://scratchya.com.ar/vue/datos.php").subscribe( 
(datos)=> {console.log('datos recibidos:' + datos); 
	this.data= datos}, 
	(error)=> (console.log('error:' + error))); }
_____

//POST 
EN EL SERVICE
create({title, body, id}): Promise<any>{
    const bodyRequest = { title, body, id }
    return this.HttpClient.post<any>(this.url, bodyRequest).toPromise()
  }
EN EL TS DEL COMPONENTE AL PULSAR UN BOTON LLAMAMOS A LA FUNCIO ONNEW
 async onNew() {
    try {
      const response = await this.web.create({title: 'foo',body: 'bar',id: 5})
      console.log(response)
    }catch (error) { console.log(error) }
  }
}

//PUT (ACTUALIZAR)
EN EL SERVICE
actualizarPut({id, title, body, userId}): Promise<any>{
    const bodyRequest = { id, title, body, userId }
    return this.HttpClient.put<any>(`${this.url}/${id}`, bodyRequest).toPromise()
  }
EN EL TS DEL COMPONENTE FUNCION QUE SE ACTIVA AL PULSAR UN BOTON
 onActualizar(){
    this.web.actualizarPut({id: 1,title: 'foo',body: 'bar',userId: 1,})
      .then(data => console.log('data', data))
      .catch(error=> console.log(error))
}

//DELETE
EN EL SERVICE
  delete(id): Promise<any>{
    return this.HttpClient.delete<any>(`${this.url}/${id}`,).toPromise()
  }
EN EL TS DEL COMPONENTE
onDelete(id) {
    this.web.delete(id)
      .then(response => console.log(response))
      .catch(error=> console.log(error))
  }

A VECES NOS PODEN QUE ENVIEMOS UN HEADER, NORMALMENTE CUANTO NECESITAMOS LOGEARNOS Y ENVIAR UN TOKEN.
NECESITAMOS IMPORTAR HTTPHEADERS EN EL SERVICES. import { HttpClient, HttpHeaders } from '@angular/common/http';
Y DENTRO DE LA FUNCION DEL POST PASAR LO QUE NOS PIDEN POR EJEMPLO EN ESTE POST  
 create({ title, body, id }): Promise<any>{
    const bodyRequest = { title, body, id }
    const httpOptions = {
      headers: new HttpHeaders({
      'Content-type': 'application/json; charset=UTF-8'
      })
    }
    return this.HttpClient.post(this.url, bodyRequest, httpOptions).toPromise() // LO PASAMOS COMO ULTIMO PARAMETRO 
  }


//PODEMOS HACERLO CON UNA ENTIDAD O MODELO (ENTITIES/ELEMENTO.TS) 
export class Elemento { codigo: string; descripcion: string; precio: string;

constructor(){
    this.codigo = '';
    this.descripcion= '';
    this.precio = '';
}

//EN EL TS import { Elemento } from './entities/elemento'; 
data:Elemento[]=[]; 
constructor(public http: HttpClient){ }

getDatos(){ 
	try{ this.http.get<Elemento[]>("https://scratchya.com.ar/vue/datos.php").subscribe( 
		(datos:Elemento[])=> {console.log('datos recibidos:' + datos); 
		this.data= datos}, (error)=> (console.log('error:' + error))); } 
	catch (error){ } }

//LA FORMA BUENA ES CREAR UN SERVICIO. 
	1-ng g s webService 
	2-Creamos un modelo (entidad) con los tributos que vamos a utilizar de los datos traidos.
	3- En el web service: 
	data:Elemento[]=[];

	constructor(public http: HttpClient) {}

	getDatos(){ 
	try{ this.http.get<Elemento[]>("https://scratchya.com.ar/vue/datos.php").subscribe( 
		(datos:Elemento[])=> {
		console.log('datos recibidos:' + datos); 
		this.data= datos}, 
		(error)=> (console.log('error:' + error))); } 
	catch (error){ } }

	4- en el app.ts import { WebServiceService } from './web-service.service'; 
		constructor(public ws: WebServiceService){ }

	5- en el html ahora llamaremos al nombre dervicio con ws delante, que es el nombre que le hemos puesto en el 		constructor. Por ejemplo:
	<p>ws.data.nombre</p>
___________________________________________________________________
PAGINACION EN APIS QUE TE DEVUELVEN EL NUMERO DE PAGINA, EJEMPLO EN GITHUB RICKY MORTY

	
___________________________________________________________________
PIPE
SI VAMOS A TRABAJAR CON DIAS, MONEDAS Y DEMAS EN ESPAÃ‘OL ESTA BIEN PONERLESO A NUESTRO PROYECTO.
PARA ESO IMPORTAMOS EN MODULE.TS LO SIGUIENTE:
import { LOCALE_ID, NgModule } from '@angular/core'; //LOCALE_ID
import { BrowserModule } from '@angular/platform-browser';
import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import locales from '@angular/common/locales/es' //LOCALES
import { registerLocaleData } from '@angular/common'; //REGISTERLOCALE DATA

registerLocaleData(locales); //LO INICIAMOS AQUI

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    HttpClientModule
  ],
  providers: [{
    provide:LOCALE_ID, useValue:'es-ES'  //LO METEMOS AQUI EN EL PROVIDE.
  }],
  bootstrap: [AppComponent]
})
export class AppModule { }
-------

ESTO ES UNA PYPE SIREVE PARA VER EN EL HTML UN OBJETO YA QUE LO PASA A STRING
{{nombre | json}}
------
CURRENCY
CON ESTE PIPE TENEMOS UN NUMERO Y SE LO MOSTRAMOS EN EL HTML DE LA MANERA QUE QUERAMOS, REDONDEANDOLO O COMO SEA SIN TOCAR EL VALOR ORIGINAL
<p>{{ precio | currency: "EUR":"symbol":"1.2-2" }}</p> 1(1 numero como minimo parte entera).2(2 numeros como minimo en la decimal)-2(dos numeros como maximo en la decimal)
-------
DECIMAL-CON ESTE PIPE MOSTRAMOS LOS DECIMALES QUE QUEREMOS A UN NUMERO EL FORMATO ES COMO EL DE CURRENCY
precio = 555,123456789
<p>{{ precio | number:"1.2-2" }}</p> minimo entero.minimo decimal-maximo decimal (se vera  555,12)
------
FECHA
fecha = new Date();
<p>{{ fecha | date: "dd-LLLL-yyyy HH:mm.ss" }}</p>  21-septiembre-2022 11:29.56
------
<p>{{ frase | lowercase }}</p>MINUSCULAS
<p>{{ frase | uppercase }}</p>MAYUSCULAS
<p>{{ frase | titlecase }}</p>MAYUSCULA EL PRINCIPIO DE CADA PALABRA
-----
CON EL PIPE SLICE LE DECIMOS EN UN NGFOR EN QUE POSICION EMPIEZA Y EN QUE POSICION ACABA DEL ARRAY
numeros = [10,20,30,40,50,60,70]
<p *ngFor="let item of numeros | slice: 0:2">{{ item }}</p> SE VERAN EL 10 Y EL 20
TAMBIEN SIRVE PARA PPONERLO EN UN STRING Y SOLO MOSTRAR LOS CARACTERES QUE QUERAMOS
palabra = 'bambi'
<p>{{palabra | slice :1.3}}  amb
-----
PIPE ASYNC CON EL RESOLVEMOS UNA PROMESA DESDE EL HTML
creamos la promesa en el service
y en el .ts del componente guardamos en una variable la llamada a la promesa;
this.prom = this.ws.getAll()  DE ESTA MANERA NO LA RESOLVEMOS.
EN EL HTML YA LA PODEMOS USAR CON PIPE ASYNC
<p>Promesa: {{prom | async}}</p> nos lo dara en formato object objetc, pero si esto mismo lo hacemos en el ngfor podremos recorrer el resultado




para crear uno propio que transforme numeros a ingles: 
1. ng g p pipes/letras 
2. En letras pipe.ts
import { Pipe, PipeTransform } from '@angular/core'; 
@Pipe({ name: 'letras' }) 
export class LetrasPipe implements PipeTransform { transform(value: any, ...args: any[]): any { 
	switch (value){ 
		case 1: return 'one' 
		case 2: return 'two' 
		case 3: return 'three' 
		case 4: return 'four' 
		case 5: return 'five' 
		default: return '' }}} 
3. en el html
	<p>{{4 | letras}}</p>
	
PIPE QUE TE ORDENA UNA LISTA. 
LISTA A ORDENAR:
articulos = [{nombre: 'David',edad : 31,totalNominas : 25000},
              {nombre: 'Jazmin',edad : 29,totalNominas : 20000},
              {nombre: 'Migue',edad : 30,totalNominas : 28000},
              {nombre: 'Sergio',edad : 33,totalNominas : 23000}]


PIPE: ORDENA LA LISTA POR EDAD
transform(lista: any[], ...args: any[]): any {
    if (!lista) return [];
    lista.sort((a:any, b:any) => {
      if (a.edad < b.edad) return -1
      else if  (a.edad == b.edad) return 0
      else return 1;
    })
    return lista
}}

HTML
<div *ngFor="let a of articulos | orderby">
  <p>{{a.nombre}}</p>
  <p>{{a.edad}}</p>
  <p>{{a.totalNominas}}</p>
</div>


------------------
PIPE PARA ORDENAR UN ARRAY EN ORDEN QUE QUERAMOS
LISTA A ORDENAR:
articulos = [{nombre: 'David',edad : 31,totalNominas : 25000},
              {nombre: 'Jazmin',edad : 29,totalNominas : 20000},
              {nombre: 'Migue',edad : 30,totalNominas : 28000},
              {nombre: 'Sergio',edad : 33,totalNominas : 23000}]
PIPE
transform(lista: any[], ...args: any[]): any {
    if (!lista) return [];
    const FieldOrder = args[0]
    lista.sort((a:any, b:any) => {
      if (a[FieldOrder] < b[FieldOrder]) return -1
      else if  (a[FieldOrder] == b[FieldOrder]) return 0
      else return 1;
    })

    return lista
  }
 
HTML
<div *ngFor="let a of articulos | orderby: 'totalNominas'">
  <p>{{a.nombre}}</p>
  <p>{{a.edad}}</p>
  <p>{{a.totalNominas}}</p>
</div>
------------------
PIPE PARA HACER UN BUSCADOR
PIPE.TS
export class SearchPipe implements PipeTransform {
//CON EL ARGS PASAMOS ARGUMENTOS, EL PRIMER ARGUMENTO ES ARGS[0]
  transform(value: any[], ...args: any[]): any {
    let buscador = args[0];
    return value.filter(a=> a.includes(buscador))
  }
}

HTML (LE PASAMOS EL ARGUMENTO BUSCADOR A palabras | nuevo: buscador)
<input type="text" [(ngModel)]="buscador">
<div *ngFor="let a of palabras | nuevo: buscador">
  <p>{{a}}</p>
</div> 
TS
buscador =''
palabras = ['cocacola', 'cocaina', 'fanta limon', 'fanta naranja', 'cerveza']

______________________________________________________________________

PARA COMPARTIR VARIABLES SE USA LOS SERVICIOS (PUEDES MOSTRAR LAS VARIABLES, MODIFICAR EL VALOR DE ESA VARIABLE DEL SERVICIO DESDE CUALQUIER COMPONENTE).
export class PersonasServiceService {
  persona : Persona
  constructor() {
    this.persona = new Persona('Jazmin', '73205874Y', 29)
   }
}
EN EL TS DE APP O DE CUALQUIER COMPONENTE YA LO PUEDES UTILIZAR, EN ESTE CASO LO ASIGNAMOS A UNA VARIABLE PERSONA1, PERO PODEMOS HASTA CAMBIAR WS.PERSONA SI QUEREMOS.
persona1: any
  constructor(public ws: PersonasServiceService){
    this.persona1 = ws.persona;
   }
   
   
   _____________________________________________
   BUSCAR INFO DE ChangeDetectionStrategy.OnPush
   ES PARA QUE SEA MAS RAPIDO EL PROGRAMA
   
   BUSCAR INFO DE CHANGED.SUBSCRIBE
   
   RETACH 
   DETACH
   
   
 ______________________________________________________________
 FORM CONTROL (FORMULARIO)

IMPORTAR EN APP.MODULE
import { ReactiveFormsModule } from '@angular/forms';
 
TS DEL COMPONENTE DEL FORMULARIO
 
import { Component, OnInit } from '@angular/core';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { ValidadorMult5 } from '../validador-mult5';

@Component({
  selector: 'app-ficha',
  templateUrl: './ficha.component.html',
  styleUrls: ['./ficha.component.scss']
})
export class FichaComponent implements OnInit {
  formulario: FormGroup = new FormGroup(
    {
      nombre: new FormControl('', [Validators.required, Validators.minLength(5)]),
      email: new FormControl('',[Validators.email]), // validators.email valida el email pero no bien, lo mejor es poner email: new FormControl('', [Validators.pattern(y aqui poner una expresion regular de email)])
      mensaje: new FormControl('', [Validators.required]),
      numero: new FormControl(0, ValidadorMult5.multiple5)
    }
  )
  constructor() { }
  
  HTML
  
  <form [formGroup]="formulario" (ngSubmit)="submit()">
    <label>Nombre:</label>
    <input type="text" formControlName="nombre">
    <span *ngIf="formulario.get('nombre')?.errors?.required">Este campo es obligatorio </span>
    <span *ngIf="formulario.get('nombre')?.errors?.minlength">Longitud minima 5</span>

    <br>
    <label>Email:</label>
    <input type="email" formControlName="email">
    <span *ngIf="formulario.get('email')?.errors?.email">Email incorrecto </span>
    <br>

    <label>Mensaje:</label>
    <textarea formControlName="Mensaje"></textarea>
    <br>
    

    <button type="submit">Enviar</button>
</form>
<p>{{ formulario.value | json }}</p>  // con esto vemos lo que vamos escribiendo en el html
//esto son las propiedades del formulario, no las de cada input,de esta manera las vemos en el htm, que sabiendolas podemos hacer cualquier cosa como poner el boton submit en disabled, poner un ngif y demas...
<p>{{formulario.valid}}</p> // es valido
<p>{{formulario.invalid}}</p> // no es valido
<p>{{formulario.dirty}}</p> // se pone a true cuando escribes en algun campo
<p>{{formulario.untouched}}</p>// se pone en false en cuanto sales de cualquier input
//Para acceder a las propiedades de cada input y poder por ejemplo darle una clase dependiendo de como este se hace con:
<p>{{formulario.controls.apellido.valid o .dirty o .untouched}}</p>


CADA INPUT TIENE UNAS CLASES COMO ng-dirty ng-touched ng-valid CON ESTAS PUEDES DARLES ESTILOS PARA QUE SE MARQUE COMO VALIDO EN VERDE E INVALIDO EN ROJO.
LOS ESTILOS SERIAN (CSS):
input.ng-valid.ng-touched {
    border: 1px solid green;
}
input.ng-invalid.ng-touched {
    border: 1px solid red;
}
input:focus { //este estilo no se si hace falta
    outline: none;
}


TAMBIEN PUEDES CREAR TU PROPIO VALIDADOR GENERANDO UNA CLASE Y LUEGO IMPORTANDOLO EN EL COMPONENTE QUE QUIERAS O CREANDO EL VALIDADOR EN EL TS DEL MISMO COMPONENTE, SI LA VALIDACION ES
CORRECTA, DEVOLVEREMOS NULL SI NO RETORNAMOS UN OBJETO CON EL NOMBRE DEL VALIDADOR: ALGUNA INFO PARA QUE LA PODAMOS VER EN EL HTML SI NOS INTERESA 
EJEMPLO VALIDACION MULTIPLO DE 5:
ng g class ValidadorMult5
import { AbstractControl, ValidationErrors } from "@angular/forms";
export class ValidadorMult5 {
    static multiple5(control: AbstractControl): ValidationErrors | null{
        let n: number = parseInt(control.value);
        if(n %5 ==0) return null
            
        else return {'multiple5': true}
    }
}

HTML

<label>Numero:</label>
    <input type="number" formControlName="numero">
    <span *ngIf="formulario.get('numero')?.errors?.multiple5">Tiene que ser multiple de 5 </span>

TS

 formulario: FormGroup = new FormGroup(
    {
      nombre: new FormControl('', [Validators.required, Validators.minLength(5)]),
      email: new FormControl('',[Validators.email]),
      mensaje: new FormControl(''),
      numero: new FormControl(0, ValidadorMult5.multiple5) //ESTE ES
    }
  )

EJEMPLO VALIDADOR EDAD ENTRE 18-65

constructor() {
     this.formulario = new FormGroup({
       nombre: new FormControl('', [Validators.minLength(6)]),
       edad: new FormControl(null, [this.validateEdad18_65]),
       email: new FormControl('')
  })}

 validateEdad18_65(FormControl:any) {
    const value = FormControl.value;
    if (value >= 18 && value <= 65) {
      return null
    }
    return {'validateEdad18_65': [65,18] };
  }

PARA MOSRTRAR LOS ERRORES DE CADA INPUT EN EL HTML:
Creamos una clase en el css:
.error {
    color: tomato;
    font-size: 12px;
}

EN EL HTML CREAMOS UN DIV DEBAJO DE CADA INPUT DONDE SE VERA EL ERROR
 <div class="formgroup">
    <label>Nommbre</label>
    <input type="text" formControlName="nombre" />
  </div>
  <div
    class="error" *ngIf="formulario.get('nombre')?.errors?.['required'] && formulario.get('nombre')?.['touched']">
    	El campo es requerido
  </div>
 <div
    class="error" *ngIf="formulario.get('nombre')?.errors?.['minlength'] && formulario.get('nombre')?.['touched']">
    El campo debe tener {{formulario.get('nombre')?.errors?.['minlength']?.['requiredLength']}} digitos almenos  //De esta manera ya te sale el numero que habiamos puesto en el minlegth en el .ts
  </div>
<p>{{ formulario.controls["nombre"].errors | json }}</p> //ASI VEMOS LAS PROPIEDADES DEL ERRORS


PODEMOS PONER UN OBSERVABLE EN EL INPUT DEL FORMULARIO QUE QUERAMOS PARA DARNOS CUENTA DE QUE CAMBIA, SE HARIA DE LA SIGUIENTE MANERA:
EN EL ONINIT NOS SUSBRIBIMOS A UN OBSERVABLE Y CON EL DEBOUNCETIME LE DECIMOS QUE NOS AVISE CUANDO ACABE DE ESCRIBIR QUE PASE MEDIO SEGUNDO.
CON ESO PODRIAMOS VALIDAR TRAYENDO DATOS DE LA ASE DE DATOS SI EL EMAIL YA ESTA EN USO O CUALQUER COSA
ngOnInit() {
    this.formulario.controls['email'].valueChanges.pipe(debounceTime(500)).subscribe(value => {
      console.log('value', value)
    })
  }


__________________________________________________
LA PAGINA SOLO PINTA LOS ELEMENTOS QUE SE VEN, AL HACER SCROLL SE IRAN PINTANDO EL RESTO DE ELEMENTOS, ESTO ES PARA UN MEJOR RENDIMIENTO

ngx-virtual-scroller
hacer el npm install
importarlo en el appmodule.ts

HTML
<virtual-scroller #scroll [items]="lista" style="height: 500px;">
  <div *ngFor="let a of scroll.viewPortItems ">
    <div style="height: 20px; border:1px solid black; margin-bottom : 3px">
        {{a}}
    </div>
  </div>
</virtual-scroller>


TS DONDE CREAMOS UNA LISTA ENORME
lista: string[]= []

  ngOnInit(): void {
    for (let i =0; i<1000; i++){
      this.lista.push('elemento' + i)
  }}

_________________________________________________________
TRANSLATE A OTRO IDIOMA

NGX TRANSLATE 

HACER LOS INSTALL

EN EL MODULE.TS

import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { ReactiveFormsModule } from '@angular/forms';
import { FichaComponent } from './ficha/ficha.component';
import { VirtualScrollerModule } from 'ngx-virtual-scroller';
import {TranslateModule, TranslateLoader} from '@ngx-translate/core';
import {TranslateHttpLoader} from '@ngx-translate/http-loader';
import { HttpClient } from '@angular/common/http';

// AoT requires an exported function for factories
export function HttpLoaderFactory(http: HttpClient) {
  return new TranslateHttpLoader(http, './assets/i18n/', '.json');
}



@NgModule({
  declarations: [
    AppComponent,
    FichaComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    ReactiveFormsModule,
    VirtualScrollerModule,
    TranslateModule.forRoot({
      loader: {
          provide: TranslateLoader,
          useFactory: HttpLoaderFactory,
          deps: [HttpClient]
      }
  }),
    
    TranslateHttpLoader
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

SE CREA ASSETS/I118N/ES.JS O ENG.JS  CON {
    "rs_aceptar": "Aceptar",
    "rs_cancelar": "Cancelar"
    ....
}

EN EL APP.COMPONENT.TS

constructor(private translate: TranslateService){
    translate.setDefaultLang('es')
    translate.use('en');
  }
  
EN EL HTML

<button>{{'rs_aceptar' | translate}}</button>








	











=======
>>>>>>> 26267c4b8f8fdc86b228ac47f468b24d645f6169

